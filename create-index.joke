#!/usr/bin/env joker

(ns script
    (:require [joker.filepath :as fp]
              [joker.string :as s]
              [joker.set :refer [union]]
              [joker.os :as os]
              [joker.hiccup :as h]
              [joker.math :as m]
              [joker.core :as j]))

(defn assert=
  [actual expected]
  (assert
    (= actual expected)
    (str "Actual: " actual "\n\nExpected: " expected)))

(defn capitalize-words [string]
  (s/join " "
          (for [word (s/split string " ")]
            (s/capitalize word))))

(defn to-title
  [filepath]
  (capitalize-words (-> filepath
                        (fp/base)
                        (s/replace "-" " ")
                        ; Remove extension
                        (s/split ".")
                        (first))))

(defn is-md? [file]
  (= "md" (last (s/split (:name file) "."))))

(defn is-symlink? [file]
  (or (= file "content/docs/history/family.md")
      (= file "content/docs/music/music-library-management.md")))
; This code only works for soft symbolic links, I can't find anything in the
; joker API that will count references to a file, which AFAICT is the only way
; to detect hard links.
#_(try (do (os/stat file) false)
       (catch Error e (try (do (os/lstat file) true
                                  (catch Error e false)))))

(assert= (is-symlink? "content/docs/manifesto.md") false)
(assert= (is-symlink? "content/docs/history/family.md") true)

(defn should-include? [file]
  (let [filepath (:name file)]
    (and (not (s/ends-with? filepath "-pics"))
         (not (s/includes? filepath "-unindexed"))
         (not (s/includes? filepath "DRAFT"))
         (not (s/includes? filepath "FREEWRITE"))
         (not (s/ends-with? filepath "all.md"))
         (or (is-md? file)
             (:dir? file))))) 

(defn file-to-link-path
  [filepath]
  (-> filepath
      (s/replace-first "content" "")
      (s/replace #".md" "/")))
  

(defn file-to-hiccup-li [filepath]
  "Converts filename like content/docs/understanding-the-world/influences.md
  into a li for the index page like
  <li><a href='/docs/understanding-the-world/influences/'>Influences</a></li>"
  [:li [:a {:href (file-to-link-path filepath)}
        (to-title filepath)]])

(defn parse-links
  "Finds all relref links in the text and returns them in a list of note names."
  [text]
  (into [] (for [match (re-seq #"relref\s+\"(.+?)\"" text)]
             (last match))))

; (j/println
;   (parse-links
;     "A subset of this is my [Experiences]({{< relref
;      \"/docs/lifestyle-optimizations/experiences.md\" >}}) page."))

(defn format-word [word]
  (s/trim (capitalize-words (s/replace word "-" " "))))

(defn extract-paragraph
  "Finds the paragraph in the given text that starts with the given prefix,
  then returns the text without the paragraph, and the paragraph."
  [text prefix]
  (if-let [paragraph (re-find (re-pattern (str "(?s)\n\n" prefix ".*?\n\n"))
                              (str text "\n\n"))]
    [(s/trim (s/replace text (str "\n\n" (s/trim paragraph)) ""))
     (s/trim paragraph)]
    [(s/trim text) ""]))

(assert=
  (extract-paragraph "

Thing: ai asnteisa 
oanetu
anote

another 'graph
hi


                        " "Thing")
  ["another 'graph\nhi" "Thing: ai asnteisa \noanetu\nanote"])
           
(defn remove-paragraph-starting-with
  [text prefix]
  (first (extract-paragraph text prefix)))

(defn is-frontmatter-delimiter?
  [line]
  (= "---" (s/trim line)))

(defn split-frontmatter-lines
  [markdown]
  (let [all-lines (s/split markdown #"\n")]
    (if (is-frontmatter-delimiter? (first all-lines))
      (let [[frontmatter body] (split-with is-frontmatter-delimiter?
                                           (rest all-lines))]
        [(into ["---"] frontmatter) body])
      ; If no frontmatter, make a blank one
      [["---" "---"] all-lines])))

(defn get-frontmatter-set
  [frontmatter-lines prefix]
  (as-> frontmatter-lines f
    (filter #(s/starts-with? % prefix) f)
    (first f)
    (if (nil? f) "" f)
    (s/replace f prefix "")
    (eval f)
    (if (set? f) f #{})))


;; ------------------ Category Management --------------------------------

(defn get-category-from-link
  [link]
  (format-word (if-let [delinked (last (re-find #"\[(.*?)\]" link))]
                 delinked
                 link)))

(defn parse-categories
  "Finds all categories in the text and returns them alongside the categoryless
  text."
  [text]
  (into
    #{}
    (for [category-link (-> (last (extract-paragraph text "Categories:"))
                            (s/replace "Categories:" "")
                            (s/trim)
                            (s/split ","))
          :let          [category (get-category-from-link category-link)]
          :when         (not (contains? #{"Game" "Experiences" ""} category))]
      category)))

(assert=
  (parse-categories
    "<markdown>

Categories: cat1, ..., [Housing]({{< relref \"/docs/all.md\" >}}?Housing=true)

other
")
  #{"Cat1" "..." "Housing"})


(assert=
  (parse-categories
    "
# My First 5.12!

I projected this route for a while and still can remember its movements.
Posting it here mostly for my own personal nostalgia : ).

Here is the route: https://photos.app.goo.gl/fvva4kiMPeRbi6tP9.

Categories: [Climbing]({{< relref \"/\" >}}?Climbing=true),
[Event Reports]({{< relref \"/\" >}}?Event-Reports=true)
Categories: [Climbing]({{< relref \"/\" >}}?Climbing=true),
[Event Reports]({{< relref \"/\" >}}?Event-Reports=true)

Backlinks: 
")
  #{"Climbing" "Event Reports"})

(defn get-categories-from-filepath
  "All directories besides content/docs in a file's path are considered
  categories."
  [file]
  (set (map format-word (drop-last (drop 2 (s/split (:path file) "/"))))))

(defn link-category
  [category]
  (let [formatted-category (format-word category)]
    (str "["
         formatted-category
         "]({{< relref \"/\" >}}?"
         (s/replace formatted-category " " "-")
         "=true)")))

(defn make-category-section
  [categories]
  (->> categories
       (sort)
       (map link-category)
       (s/join ",\n")
       (str "Categories:\n")))

(def categories-prefix "categories-set: ")

(defn add-categories-frontmatter
  [markdown categories]
  (let [[frontmatter body]  (split-frontmatter-lines markdown)
        categories-set      (union (get-frontmatter-set frontmatter
                                                        categories-prefix)
                                   categories)
        updated-frontmatter (as-> frontmatter f
                              (remove #(s/starts-with? % categories-prefix) f)
                              (apply conj
                                [(first f)]
                                (str categories-prefix categories-set)
                                (rest f)))]
    (s/join "\n" (concat updated-frontmatter body))))


;; ------------------ Backlink Management --------------------------------

(defn file-to-md-link
  [filepath]
  (str "["
       (to-title filepath)
       "]({{< relref \""
       (s/replace-first filepath "content" "")
       "\" >}})"))

(defn make-backlinks-section
  [backlinks]
  (if (or (nil? backlinks) (= 0 (count backlinks)))
    ""
    (->> backlinks
         (sort)
         (map file-to-md-link)
         (s/join ",\n")
         (str "Backlinks:\n"))))

; Helper function for update-files-with-backlinks
(defn get-file-to-backlinks
  [all-files]
  (apply merge-with
    into
    (reduce concat
      (for [file all-files]
        (for [link  (:links file)
              :when (not (= "/docs/all.md" link))]
          {link #{(:path file)}})))))

; TODO update this code to link to specific md sections, not just pages as a
; whole. this is particularly helpful for the "feelings" page and how it
; interacts with "experiences"
(defn update-files-with-backlinks
  [all-files]
  (let [path-to-backlinks (get-file-to-backlinks all-files)]
    (for [file all-files]
      (as-> file f
        (assoc f
          :backlinks (get path-to-backlinks
                          (s/replace-first (:path f) "content" "")))
        #_(assoc f
            :backlinks-section (make-backlinks-section (:backlinks f)))))))

(def backlinks-prefix "backlinks-set: ")

(defn add-backlinks-frontmatter
  [markdown backlinks]
  (let [[frontmatter body]  (split-frontmatter-lines markdown)
        updated-frontmatter (as-> frontmatter f
                              (remove #(s/starts-with? % backlinks-prefix) f)
                              (apply conj
                                [(first f)]
                                (str backlinks-prefix backlinks)
                                (rest f)))]
    (s/join "\n" (concat updated-frontmatter body))))

;; ------------------ All File Data Construction --------------------------

(defn add-file-data
  [file]
  (prn (str "Processing data for " (:path file)))
  ; Assume symlinks are links to private repositories that we do not
  ; want included in the indexed data.
  (let [markdown (if (is-symlink? (:path file))
                   "This file is encrypted."
                   (slurp (:path file)))]
    (as-> file f
      (merge f
             {:path-categories (get-categories-from-filepath file)
              :markdown markdown
              :modification-unix-timestamps
              (mapv parse-long
                (s/split (s/trim (:out (os/sh "git"
                                              "log" "--pretty=format:%ct"
                                              "--"  (:path file))))
                         #"\n"))
              :links (parse-links markdown)
              :title (to-title (:path file))})
      (assoc f
        :categories (union (:path-categories f) (parse-categories markdown))))))


(defn generate-final-markdown
  [file]
  (-> (:markdown file)
      (remove-paragraph-starting-with "Backlinks:")
      (remove-paragraph-starting-with "Categories:")
      (add-categories-frontmatter (:categories file))
      (add-backlinks-frontmatter (:backlinks file))))
  ; (s/trim (str (:sectionless-markdown file))))
              ; This hardcodes categories and backlinks, but now we are
              ; dynamically generating a sidebar with this info using
              ; website-helpers!)))
              ; "\n\n" (:categories-section file)
              ; "\n\n" (:backlinks-section file))))

; Helper function for get-all-files and get-file-tree
(defn get-files
  [filepath]
  (sort-by
    (fn [file] [(:dir? file) (:name file)])
    (for [file  (os/ls filepath)
          :when (should-include? file)]
      (let [pathed-file (assoc file :path (fp/join filepath (:name file)))]
        (if (:dir? pathed-file) pathed-file (add-file-data pathed-file))))))

(defn get-all-files
  [filepath]
  (->> filepath
      (get-files)
      (filter should-include?)
      (map #(if (:dir? %) (get-all-files (:path %)) [%]))
      (reduce concat)
      (update-files-with-backlinks)
      (map #(assoc % :markdown (generate-final-markdown %)))))

; DOES NOT include backlink information!
(defn get-file-tree
  [filepath]
  (into []
        (for [{:keys [path size name dir?]} (get-files filepath)]
          (let [file {:name name :size size}]
            (if dir? (assoc file :children (get-file-tree path)) file)))))

;; ---------------- Directory Section Management -------------------------

(declare make-dir-into-header)

(defn make-dir-contents
  [filepath]
  [:ul
   (for [file (get-files filepath)]
     (cond (:dir? file)  (make-dir-into-header file filepath)
           (is-md? file) (file-to-hiccup-li (fp/join filepath (:name file)))
           :else         [:div "bad " file]))])
  
(defn make-dir-into-header
  [file cur-path]
  "Converts file map like {:dir? true :name my-dir} into collapsed html ul with 
  a bold header. Recursively generates all sub-directories."
  (let [filepath   (fp/join cur-path (:name file))
        inner-list (make-dir-contents filepath)]
    (j/println filepath)
    (if (= (count (last inner-list)) 0)
      nil
      [:li
       [:details {:id (:name file)}
        [:summary [:strong (to-title filepath)]]
        inner-list]])))

;; ------------- Experiences.edn to Markdown Files -------------------------

(defn remove-md-link
  [md]
  (if-let [delinked (last (re-find #"\[(.*?)\]" md))]
    delinked
    md))

(defn clean-whitespace
  [md]
  "Removes multiple spaces and newlines."
  (s/replace (s/replace md "\n" "") #"\s\s+" " "))

(defn name-to-anchor-link [s] (str "#" (s/replace (s/lower-case s) " " "-")))

(defn make-feelings-list
  [feelings]
  (s/join "\n"
          (for [[feeling desc] feelings]
            (str "  - ["
                 feeling
                 "]({{< relref \"/docs/feelings.md\" >}}"
                 (name-to-anchor-link feeling)
                 ")"))))

(defn experiences-to-md
  [experiences-edn]
  (doall (for [[title description tags feelings] experiences-edn
               :let [clean-title (clean-whitespace title)
                     filename    (str "content/docs/experiences/"
                                      (s/replace (remove-md-link clean-title)
                                                 " "
                                                 "-")
                                      ".md")
                     body        (str "# "
                                      clean-title
                                      "\n\n"
                                      (clean-whitespace description)
                                      "\n\n"
                                      "Feelings: \n\n"
                                      (make-feelings-list feelings)
                                      "\n\n"
                                      "Categories: "
                                      (s/join ", " tags))]]
           (spit filename body))))

(defn get-all-feelings
  [experiences]
  (sort-by #(first %)
           (reduce concat
             (for [[_ _ _ feelings] experiences]
               feelings))))

(defn feelings-to-file
  [experiences-edn]
  (spit "content/docs/feelings.md"
        (str "# Feelings\n\n"
             (s/join "\n\n"
                     (for [[feeling description valences] (get-all-feelings
                                                            experiences-edn)
                           :when (not (nil? description))]
                       (str "## "  feeling
                            "\n\n" (clean-whitespace description)
                            "\n"   (if valences
                                     (str "\n"
                                          (s/join "\n"
                                                  (for [v valences]
                                                    (str "  - " v))))
                                     "")))))))
                    
; -------------------------------------------------------------------------

; ------------------------- All Note Page ---------------------------------

; I feel like this truncation is not really going to work.
; https://eddmann.com/posts/checking-for-balanced-parentheses-in-clojure/
; (defn balanced?
;   {:test #(do
;             (assert (true? (balanced? "(hello(world))")))
;             (assert (false? (balanced? "he)llo()world"))))}
;   ([expr] (balanced? (s/split expr #"") 0))
;   ([[x & xs] count]
;    (cond (neg? count) false
;          (nil? x) (zero? count)
;          (= x "(") (recur xs (inc count))
;          (= x ")") (recur xs (dec count))
;          :else (recur xs count))))
; (def min-chars 200)
; (defn truncate-md [md]
;   (let [start (subs md 0 (min (count md) min-chars)) ; At least min-chars
;         end (subs md (min (count md) min-chars))]
;     (str
;       (if (balanced? start)
;           start
;           ; Enough chars to close any parens
;           (str 
;             start
;             (subs end 0 (min (if-let [i (s/index-of end ")")] i (count md))
;                              (count md)))))
;       "...")))

(defn drop-frontmatter [md]
  (if (s/starts-with? md "---")
    (s/join "\n\n" (drop 1 (s/split md "\n\n")))
    md))

(defn truncate-md
  [md]
  "Grabs the title and first paragraph from the given markdown."
  (let [[p1 p2] (take 2 (s/split (drop-frontmatter md) "\n\n"))]
    (str "#"
         p1
         "\n\n"
         (if (and (not (nil? p2)) (s/starts-with? p2 "#")) "" p2)
         "...")))
  

(defn make-all-notes-page
  [notes]
  (str "# All Notes\n\n"
       (s/join "\n\n"
               (sort (for [{:keys [markdown path]} notes]
                       (truncate-md markdown))))))
    
; -------------------------------------------------------------------------

(def harry-potter-sorcerers-stone-words
  76944)

(def letters
  (into #{} (seq "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")))

(defn is-word
  [string]
  (contains? letters (first string)))
  

(defn word-count
  [files]
  (let [word-count (as-> files d
                     (map :markdown d)
                     (reduce str d)
                     (s/split d #"\s+")
                     (filter is-word d)
                     (count d))]
    (str word-count
         " words, "
         (m/round
           (* 100 (double (/ word-count harry-potter-sorcerers-stone-words))))
         "% of Harry Potter and the Sorcerer's Stone")))

(defn update-word-count
  [filepath all-files]
  (let [prefix "Whole site count: "
        [countless-text _] (extract-paragraph (slurp filepath) prefix)]
    (spit filepath 
          (str countless-text "\n\n" prefix (word-count all-files)))))


(def index-path "content/menu/index.md")
; Path to all the pages that we want to process.
(def content-path "content/docs/visual-art")
; (def content-path "content/docs")
(defn main []
  (let [all-files (get-all-files content-path)]
    (spit "content/docs/all.edn" 
          ; THIS EATS DEBUGGING PRINT STATEMENTS!!!
          (with-out-str (pprint (into [] all-files))))
    (spit "content/docs/all.md" (make-all-notes-page all-files))
    (prn (word-count all-files))
    (update-word-count "content/_index.md" all-files)
    (doall (for [file all-files
                 ; Assume symlinks are links to private repositories that we
                 ; do not want to modify. 
                 :when (not (is-symlink? (:path file)))]
             (spit (:path file) (:markdown file))))))

  ; Skip generating experience md pages from the edn file for now.
  ; (let [experiences-edn
  ;       (read-string
  ;         (slurp "content/docs/lifestyle-optimizations/experiences.edn")))
  ;   (feelings-to-file experiences-edn)
  ;   (experiences-to-md experiences-edn))

  ; Actually generate the index.  This code is obseleted by the website-helpers
  ; index generation
  ; (spit index-path (h/html (make-dir-contents content-path)))
  ; (spit "content/menu/index.edn" (get-file-tree content-path))
  ; ; Requires `sudo apt install tidy`
  ; (os/sh "tidy"
  ;        "-indent"
  ;        "--show-body-only" "yes"
  ;        "--doctype" "omit"
  ;        "--tidy-mark" "no"
  ;        "-omit"
  ;        "-o" index-path index-path) 
  ; ; Prepend hugo fontmatter
  ; (os/sh "sed" "-i" "1s;^;---\\nheadless: true\\n---\\n;" index-path))

(main)
