#!/usr/bin/env joker

(ns script
    (:require [joker.filepath :as fp]
              [joker.string :as s]
              [joker.os :as os]
              [joker.hiccup :as h]
              [joker.core :as j]))

(defn capitalize-words [string]
  (s/join " "
          (for [word (s/split string " ")]
            (s/capitalize word))))

(defn to-title [filepath]
  (capitalize-words
    (-> filepath
        (fp/base)
        (s/replace "-" " ")
        ; Remove extension
        (s/split ".")
        (first))))

(defn is-md? [file]
  (= "md" (last (s/split (:name file) "."))))

(defn should-include? [file]
  (let [filepath (:name file)]
    (and (not (s/ends-with? filepath "-pics"))
         (not (s/includes? filepath "-unindexed"))
         (not (s/includes? filepath "DRAFT"))
         (not (s/includes? filepath "FREEWRITE"))
         (or (is-md? file)
             (:dir? file))))) 

(defn make-file-into-li [filepath]
  "Converts filename like content/docs/understanding-the-world/influences.md
  into a li for the index page like
  <li><a href='/docs/understanding-the-world/influences/'>Influences</a></li>"
  [:li [:a {:href (-> filepath
                      (s/replace-first "content" "")
                      (s/replace #".md" "/"))}
        (to-title filepath)]])

(defn parse-links
  "Finds all relref links in the text and returns them in a list of note names."
  [text]
  (for [match (re-seq #"relref\s+\"(.+)\"" text)]
    (last match)))

; (j/println
;   (parse-links
;     "A subset of this is my [Experiences]({{< relref
;      \"/docs/lifestyle-optimizations/experiences.md\" >}}) page."))

(defn parse-categories
  "Finds all categories the text and returns them."
  [text]
  (into #{} (reduce concat
              (for [match (re-seq #"\nCategories: (.+)" text)]
                (for [category (s/split (last match) ",")]
                  (s/trim category))))))

; (j/println
;   (parse-categories
;     "<markdown>
; 
; Categories: cat1, cat2, ...
; "))


(defn add-file-data [file]
  (let [markdown (slurp (:path file))]
    (merge file
      {:categories (parse-categories markdown)
       :markdown markdown
       :links (parse-links markdown)
       :title (to-title (:path file))})))

(defn get-files [filepath]
  (sort-by (fn [file] [(:dir? file) (:name file)])
           (for [file (os/ls filepath)
                 :when (should-include? file)]
             (let [pathed-file
                   (assoc file :path (fp/join filepath (:name file)))]
               (if (:dir? pathed-file)
                 pathed-file
                 (add-file-data pathed-file))))))

(defn get-all-files
  [filepath]
  (reduce concat
          (for [file (get-files filepath)
                :when (should-include? file)]
            (if (:dir? file)
              (get-all-files (:path file)) 
              [file]))))


(defn get-file-tree
  [filepath]
  (into [] (for [{:keys [path size name dir?]} (get-files filepath)]
             (let [file {:name name
                         :size size}]
               (if dir?
                 (assoc file :children (get-file-tree path)) 
                 file)))))

(declare make-dir-into-header)

(defn make-dir-contents [filepath]
  [:ul (for [file (get-files filepath)] 
         (cond
            (:dir? file)
            (make-dir-into-header file filepath)
            (is-md? file)
            (make-file-into-li (fp/join filepath (:name file)))
            :else
            [:div "bad " file]))])
  
(defn make-dir-into-header [file cur-path]
  "Converts file map like {:dir? true :name my-dir} into collapsed html ul with 
  a bold header. Recursively generates all sub-directories."
  (let [filepath (fp/join cur-path (:name file))
        inner-list (make-dir-contents filepath)]
    (j/println filepath)
    (if (= (count (last inner-list)) 0)
      nil
      [:li [:details {:id (:name file)}
            [:summary [:strong (to-title filepath)]] inner-list]])))

;; ------------- Adding Categories based on Directory Structure ------------

; Only run this once to avoid duplication!
(defn add-dir-categories [root-dir]
  (doall (for [file (get-all-files root-dir)
               :let [categories (drop-last (drop 2 (s/split (:path file) "/")))]]
           (prn (:path file) (s/join ", " categories))))) 
           ; (spit (:path file)
           ;     (str "\n\nCategories: " (s/join ", " categories)))))
           ;     :append true)))

; TODO run this for real
(add-dir-categories "content/docs")
 



; -------------------------------------------------------------------------

;; ------------- Experiences.edn to Markdown Files -------------------------

(defn remove-md-link [md]
  (if-let [delinked (last (re-find #"\[(.*?)\]" md))]
    delinked md))

(defn clean-whitespace [md]
  "Removes multiple spaces and newlines."
  (s/replace (s/replace md "\n" "")
             #"\s\s+" " "))

(defn name-to-anchor-link [s]
  (str "#" (s/replace (s/lower-case s) " " "-")))

(defn make-feelings-list [feelings]
  (s/join "\n"
          (for [[feeling desc] feelings]
            (str "  - [" feeling
                 "]({{< relref \"/docs/feelings.md\" >}}"
                 (name-to-anchor-link feeling) ")"))))

(defn experiences-to-md [experiences-edn]
  (doall (for [[title description tags feelings] experiences-edn
               :let [clean-title (clean-whitespace title)
                     filename (str "content/docs/experiences/"
                                   (s/replace (remove-md-link clean-title)
                                              " " "-")
                                   ".md")
                     body (str "#" clean-title "\n\n"
                               (clean-whitespace description) "\n\n"
                               "Feelings: " (make-feelings-list feelings) "\n\n"
                               "Categories: " (s/join ", " tags))]]
            (spit filename body))))

(defn get-all-feelings [experiences]
  (sort-by #(first %)
    (reduce concat (for [[_ _ _ feelings] experiences]
                     feelings))))

(defn feelings-to-file [experiences-edn]
  (spit "content/docs/feelings.md"
    (str "# Feelings\n\n"
          (s/join "\n\n"
                  (for [[feeling description valences]
                        (get-all-feelings experiences-edn)
                        :when (not (nil? description))]
                    (str "## " feeling "\n\n" (clean-whitespace description)
                         "\n"
                         (if valences
                           (str "\n"
                                (s/join "\n" (for [v valences] 
                                               (str "  - " v))))
                           "")))))))
                    
; -------------------------------------------------------------------------
    


(def index-path "content/menu/index.md")
(defn main []
  (spit index-path (h/html (make-dir-contents "content/docs")))
  (spit "content/menu/index.edn" (get-file-tree "content/docs"))
  (spit "content/all.edn" 
        (with-out-str (pprint (get-all-files "content/docs"))))

  (let [experiences-edn
        (read-string
          (slurp "content/docs/lifestyle-optimizations/experiences.edn"))]
    (feelings-to-file experiences-edn)
    (experiences-to-md experiences-edn))

  ; Requires `sudo apt install tidy`
  (os/sh "tidy"
         "-indent"
         "--show-body-only" "yes"
         "--doctype" "omit"
         "--tidy-mark" "no"
         "-omit"
         "-o" index-path index-path) 
  ; Prepend hugo fontmatter
  (os/sh "sed" "-i" "1s;^;---\\nheadless: true\\n---\\n;" index-path))

; (main)
